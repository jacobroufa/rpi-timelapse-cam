---
phase: 03-timelapse-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/timelapse/generate.py
  - src/timelapse/__main__.py
  - pyproject.toml
autonomous: true
requirements: [TL-01, TL-02, TL-03, TL-04, TL-05]

must_haves:
  truths:
    - "User can run `timelapse generate --start 2026-01-01 --range 7d` and get a timelapse MP4"
    - "User can run `timelapse generate --start 2026-01-01 --end 2026-01-07 --duration 2m` and get a 2-minute video"
    - "User sees a progress bar during encoding and a summary line at the end"
    - "Running with --dry-run shows image count, FPS, duration, and output path without encoding"
    - "Script errors clearly if FFmpeg is not installed, with platform-specific install instructions"
    - "Script errors clearly if zero images are found in the date range"
    - "Script works on any machine with Python, FFmpeg, and access to the image directory"
  artifacts:
    - path: "src/timelapse/generate.py"
      provides: "Core timelapse generation: image collection, FPS calc, concat file, FFmpeg invocation, progress"
      min_lines: 200
    - path: "src/timelapse/__main__.py"
      provides: "CLI subcommand 'generate' with all date/duration/output flags"
      contains: "generate"
  key_links:
    - from: "src/timelapse/__main__.py"
      to: "src/timelapse/generate.py"
      via: "import and call from _run_generate subcommand handler"
      pattern: "from timelapse\\.generate import"
    - from: "src/timelapse/generate.py"
      to: "src/timelapse/config.py"
      via: "load_config for output_dir resolution when --images not given"
      pattern: "from timelapse\\.config import load_config"
    - from: "src/timelapse/generate.py"
      to: "ffmpeg binary"
      via: "subprocess.Popen with concat demuxer"
      pattern: "subprocess\\.Popen"
---

<objective>
Implement the complete timelapse video generation feature: a core Python module with image collection, FPS calculation, FFmpeg concat demuxer integration, and progress reporting, plus a CLI subcommand wired into the existing entry point.

Purpose: This is the final phase of the project -- enabling users to turn their captured images into timelapse videos with a single command.
Output: Working `timelapse generate` subcommand that produces MP4 videos from date ranges of captured images.
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-timelapse-generation/03-CONTEXT.md
@.planning/phases/03-timelapse-generation/03-RESEARCH.md
@src/timelapse/__main__.py
@src/timelapse/config.py
@src/timelapse/storage/manager.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core timelapse generation module</name>
  <files>src/timelapse/generate.py</files>
  <action>
Create `src/timelapse/generate.py` with the following functions. Use only stdlib + Pillow (already installed). No new dependencies.

**FFmpeg check:**
- `check_ffmpeg() -> str` -- uses `shutil.which("ffmpeg")`, returns path or exits with clear platform-specific install instructions (Debian/Ubuntu/Pi: `sudo apt install ffmpeg`, macOS: `brew install ffmpeg`, Windows: `choco install ffmpeg` / `scoop install ffmpeg`).

**Image collection:**
- `collect_images(base_dir: Path, start: date, end: date, use_thumbnails: bool = False, every_n: int = 1, sort: str = "filename") -> list[Path]` -- walks `base_dir/YYYY/MM/DD/[thumbs/]*.jpg` for each day in range. Default sort by filename (chronological due to HHMMSS.jpg naming). Support sort options: `filename` (default), `mtime` (file modification time), `random` (shuffle). Apply `every_n` subsampling after sorting.

**Gap detection:**
- `detect_gaps(base_dir: Path, start: date, end: date) -> list[date]` -- returns dates with no images in the range.

**FPS calculation:**
- `calculate_fps(image_count: int, target_seconds: float, max_fps: float = 30.0) -> tuple[float, int]` -- returns `(fps, every_n)`. If calculated fps exceeds max_fps, auto-subsample: `every_n = ceil(fps / max_fps)`, `fps = image_count / every_n / target_seconds`. Default max_fps is 30 for broad player compatibility per research.

**Resolution detection:**
- `detect_resolution(image_paths: list[Path], explicit: tuple[int, int] | None = None) -> tuple[int, int] | None` -- if explicit is given, return it. Otherwise sample first, middle, and last images with `PIL.Image.open(path).size` (lazy, header only). If all same, return None (no scaling needed). If mixed, scan all images and return the minimum width and minimum height. Return None means "no -vf filter needed".

**Concat file generation:**
- `write_concat_file(image_paths: list[Path], fps: float) -> Path` -- creates a `tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False, prefix="timelapse_")`. Writes `file 'ABSOLUTE_PATH'\nduration FLOAT\n` for each image. Repeats last image entry without duration (concat demuxer last-duration bug workaround). Returns path to the temp file.

**FFmpeg command construction:**
- `build_ffmpeg_cmd(ffmpeg_path: str, concat_file: Path, output_path: Path, fps: float, resolution: tuple[int, int] | None = None, codec: str = "libx264") -> list[str]` -- builds the command list. Includes: `-y` (overwrite), `-f concat`, `-safe 0`, `-i CONCAT_FILE`, `-c:v CODEC`, `-pix_fmt yuv420p`, `-r FPS` (capped at 60), `-progress pipe:1`, `-nostats`. If resolution is not None, add `-vf scale=W:H:force_original_aspect_ratio=decrease,pad=W:H:(ow-iw)/2:(oh-ih)/2`. Append output path.

**FFmpeg execution with progress:**
- `run_ffmpeg(cmd: list[str], total_frames: int, show_progress: bool = True, verbose: bool = False) -> None` -- runs via `subprocess.Popen(cmd, stdout=PIPE, stderr=PIPE, text=True)`. If show_progress, parse `frame=N` lines from stdout and render `\r[####----] 45% (N/TOTAL frames)` to stderr. If verbose, also print FFmpeg's stderr at the end. On `progress=end`, break. After proc.wait(), if returncode != 0, raise RuntimeError with FFmpeg stderr. Always print a newline to stderr after progress bar.

**Duration parser:**
- `parse_duration(value: str) -> int` -- custom argparse type. Parses `90s`, `2m`, `1h30m` into total seconds. Raises `argparse.ArgumentTypeError` on invalid input.

**Range parser:**
- `parse_range(value: str) -> str` -- custom argparse type. Validates format `Nd`, `Nw`, `Nm`. Returns raw string (date calculation happens after --start is known).
- `range_to_end_date(start: date, range_str: str) -> date` -- converts range string to end date relative to start. `d` = days (inclusive, so 7d from Jan 1 = Jan 7), `w` = weeks, `m` = months (handling month boundaries with `calendar.monthrange`).

**Top-level generate function:**
- `generate_timelapse(images_dir: Path, start: date, end: date, duration_seconds: int = 120, output_path: Path | None = None, use_thumbnails: bool = False, every_n: int = 1, sort: str = "filename", resolution: tuple[int, int] | None = None, codec: str = "libx264", dry_run: bool = False, show_progress: bool = True, verbose: bool = False, silent: bool = False) -> Path` -- orchestrates the full pipeline:
  1. `check_ffmpeg()`
  2. `collect_images(...)` -- if zero images, print clear error (`No images found for START to END in PATH`) and `sys.exit(1)`
  3. `detect_gaps(...)` -- if gaps and not silent, print warning to stderr listing missing dates
  4. `calculate_fps(len(images), duration_seconds)` -- if auto-subsampling occurs, apply it to images list and print note
  5. `detect_resolution(images, resolution)` -- determine if scaling filter needed
  6. Generate default output path if not given: `timelapse_YYYY-MM-DD_YYYY-MM-DD.mp4` in current working directory
  7. If dry_run: print image count, calculated FPS, estimated duration, output path, then return
  8. `write_concat_file(images, fps)`
  9. `build_ffmpeg_cmd(...)`
  10. `run_ffmpeg(cmd, len(images), show_progress, verbose)`
  11. Clean up temp concat file
  12. Print summary line: output path, file size, actual duration (from ffprobe if available, else estimated)
  13. Return output path
  </action>
  <verify>
`python -c "from timelapse.generate import generate_timelapse, calculate_fps, parse_duration, parse_range; print('imports OK')"` succeeds. `python -c "from timelapse.generate import calculate_fps; fps, every = calculate_fps(10080, 120); print(f'fps={fps}, every={every}')"` prints reasonable values (fps <= 30, every > 1).
  </verify>
  <done>
`src/timelapse/generate.py` exists with all functions listed above. Module imports cleanly. `calculate_fps(10080, 120)` returns fps <= 30 with auto-subsampling. `parse_duration("2m")` returns 120. `parse_range("7d")` returns "7d".
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI subcommand and entry point wiring</name>
  <files>src/timelapse/__main__.py, pyproject.toml</files>
  <action>
**Update `src/timelapse/__main__.py`:**

Add a `generate` subcommand to the existing argparse setup, following the same pattern as `generate-thumbnails`. Add it after the existing `generate-thumbnails` subcommand parser.

Arguments for the `generate` subparser (all per user's locked decisions):
- `--start` (required=True, type=lambda s: date.fromisoformat(s), help="Start date (YYYY-MM-DD)")
- Mutually exclusive group (required=True): `--end` (type=date.fromisoformat) and `--range` (type=parse_range from generate module)
- `--duration` (type=parse_duration from generate module, default=120, help="Target video duration (e.g. 2m, 90s, 1h30m). Default: 2m")
- `--images` (type=Path, default=None, help="Image directory (overrides config output_dir)")
- `--output` (type=Path, default=None, help="Output video file path (default: ./timelapse_START_END.mp4)")
- `--thumbnails` (action="store_true", help="Use thumbnail images for quick preview")
- `--every` (type=int, default=1, help="Use every Nth image (default: 1 = all)")
- `--sort` (choices=["filename", "mtime", "random"], default="filename", help="Image sort order")
- `--resolution` (type=str, default=None, help="Output resolution WxH (e.g. 1920x1080). Default: source resolution")
- `--codec` (type=str, default="libx264", help="FFmpeg video codec (default: libx264)")
- `--dry-run` (action="store_true", help="Show what would be done without encoding")
- `--summary-only` (action="store_true", help="Suppress progress bar, show only final summary")
- `--verbose` (action="store_true", help="Show detailed output including FFmpeg messages")
- `--silent` (action="store_true", help="Suppress gap warnings")
- `--config` (type=Path, default=None, same help as existing)

Add `_run_generate(args)` handler function:
1. Parse --resolution string "WxH" into tuple if provided, or None
2. Determine images_dir: if `--images` given, use it directly. Otherwise, resolve config (using `_resolve_config`), call `load_config`, get `config["storage"]["output_dir"]`.
3. Compute end date: if `--range` given, import and call `range_to_end_date(args.start, args.range)`. If `--end` given, use directly.
4. Call `generate_timelapse(images_dir=..., start=args.start, end=end_date, duration_seconds=args.duration, output_path=args.output, use_thumbnails=args.thumbnails, every_n=args.every, sort=args.sort, resolution=resolution, codec=args.codec, dry_run=args.dry_run, show_progress=not args.summary_only, verbose=args.verbose, silent=args.silent)`.

Update the dispatch in `main()`: add `elif args.command == "generate": _run_generate(args)`.

Add `from datetime import date` to imports.

**Update `pyproject.toml`:**

Add a `timelapse-generate` console_scripts entry point alongside the existing `timelapse` entry:
```
timelapse-generate = "timelapse.__main__:main"
```

This reuses the same `main()` function -- users would call `timelapse-generate generate --start ...`. For a cleaner standalone experience, this is acceptable since the subcommand name is explicit.

**Update program description** in argparse to mention video generation:
```
description="Raspberry Pi timelapse capture daemon and video generator"
```
  </action>
  <verify>
`python -m timelapse generate --help` shows all expected flags (--start, --end, --range, --duration, --images, --output, --thumbnails, --every, --sort, --resolution, --codec, --dry-run, --summary-only, --verbose, --silent). `python -m timelapse generate --start 2026-01-01 --range 7d --dry-run --images /tmp` runs without error (will show "No images found" message since /tmp has no timelapse images, which is correct behavior).
  </verify>
  <done>
`timelapse generate --help` displays all CLI flags matching the locked decisions. `--start` is required. `--end` and `--range` are mutually exclusive and one is required. `--duration` defaults to 2m (120s). `--dry-run` works. `--images` overrides config. Running against an empty directory produces the clear "No images found" error. `pyproject.toml` has the `timelapse-generate` entry point.
  </done>
</task>

</tasks>

<verification>
1. `python -m timelapse generate --help` shows all expected flags
2. `python -c "from timelapse.generate import calculate_fps; print(calculate_fps(10080, 120))"` returns (fps <= 30, every_n > 1)
3. `python -c "from timelapse.generate import parse_duration; print(parse_duration('2m'))"` returns 120
4. `python -c "from timelapse.generate import parse_duration; print(parse_duration('90s'))"` returns 90
5. `python -c "from timelapse.generate import parse_range, range_to_end_date; from datetime import date; print(range_to_end_date(date(2026,1,1), parse_range('7d')))"` returns 2026-01-07
6. `python -m timelapse generate --start 2026-01-01 --range 7d --dry-run --images /tmp` exits with clear "No images found" message
7. If test images are available: `python -m timelapse generate --start DATE --end DATE --images PATH --dry-run` shows correct image count, FPS, and output path
</verification>

<success_criteria>
- `timelapse generate` subcommand works end-to-end: date range input -> image collection -> FPS calculation -> FFmpeg encoding -> MP4 output
- All locked CLI flags are implemented: --start, --end, --range, --duration, --images, --output, --thumbnails, --every, --sort, --resolution, --codec, --dry-run, --summary-only, --verbose, --silent
- Default behavior matches TL-02: 1 week of captures compresses into a 2-minute video
- FPS auto-capped at 30 with automatic subsampling when needed
- Progress bar displays during encoding (unless --summary-only)
- Gap warnings shown for missing days (unless --silent)
- Clear errors for: missing FFmpeg, zero images, invalid arguments
- No new Python dependencies -- stdlib + existing Pillow only
</success_criteria>

<output>
After completion, create `.planning/phases/03-timelapse-generation/03-01-SUMMARY.md`
</output>
