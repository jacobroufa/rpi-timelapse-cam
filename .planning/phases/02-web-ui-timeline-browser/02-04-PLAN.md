---
phase: 02-web-ui-timeline-browser
plan: 04
type: execute
wave: 2
depends_on: [02-02]
files_modified:
  - src/timelapse/web/blueprints/latest.py
  - src/timelapse/web/templates/latest.html
  - src/timelapse/web/static/js/latest.js
  - systemd/timelapse-web.service
  - scripts/setup.sh
autonomous: true
requirements: [WEB-02, WEB-09]

must_haves:
  truths:
    - "Latest Image tab shows the most recently captured image"
    - "Image auto-refreshes at the configured capture interval"
    - "Capture interval is displayed so user knows refresh frequency"
    - "When daemon is stopped or camera offline, last captured image is shown with a status banner"
    - "Timestamp overlay shows when the displayed image was captured"
    - "Web server runs as a systemd service that starts on boot"
  artifacts:
    - path: "src/timelapse/web/blueprints/latest.py"
      provides: "Latest Image routes: index page and image endpoint"
      exports: ["latest_bp"]
      contains: "Cache-Control"
    - path: "src/timelapse/web/templates/latest.html"
      provides: "Latest Image tab with auto-refreshing image and status banner"
      contains: "latest-image"
    - path: "src/timelapse/web/static/js/latest.js"
      provides: "Auto-refresh polling with setInterval"
      contains: "setInterval"
    - path: "systemd/timelapse-web.service"
      provides: "systemd unit file for the Flask web server"
      contains: "timelapse-web"
  key_links:
    - from: "src/timelapse/web/static/js/latest.js"
      to: "src/timelapse/web/blueprints/latest.py"
      via: "polling /latest/image with cache-busting timestamp"
      pattern: "latest/image"
    - from: "src/timelapse/web/blueprints/latest.py"
      to: "filesystem"
      via: "reverse directory walk to find newest JPEG"
      pattern: "reverse=True"
    - from: "systemd/timelapse-web.service"
      to: "src/timelapse/web/__init__.py"
      via: "flask run command pointing to app factory"
      pattern: "timelapse.web"
---

<objective>
Build the Latest Image tab with auto-refreshing display and the systemd service unit for the web server. The Latest Image tab shows the most recently captured image with automatic refresh at the capture interval, status banners for offline states, and a timestamp overlay. The systemd service ensures the web server starts on boot and restarts on failure.

Purpose: The Latest Image tab provides a quick "what's happening now" view without requiring navigation. Combined with the systemd service, the web UI is always available when the Pi is running. Per user decision, this is renamed from "Live View" to "Latest Image" to set correct expectations.

Output: Working Latest Image tab with auto-refresh, offline status handling, and timelapse-web.service systemd unit.
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-web-ui-timeline-browser/02-RESEARCH.md
@.planning/phases/02-web-ui-timeline-browser/02-02-SUMMARY.md
@src/timelapse/web/__init__.py
@src/timelapse/web/blueprints/latest.py
@src/timelapse/web/templates/base.html
@systemd/timelapse-capture.service
@scripts/setup.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Latest Image blueprint, template, and auto-refresh JS</name>
  <files>src/timelapse/web/blueprints/latest.py, src/timelapse/web/templates/latest.html, src/timelapse/web/static/js/latest.js</files>
  <action>
Replace the stub latest blueprint with the full implementation.

`src/timelapse/web/blueprints/latest.py` routes:

1. `GET /` (latest.index): Renders latest.html. Passes to template:
   - `capture_interval`: from app.config["TIMELAPSE"]["capture"]["interval"] (in seconds)
   - `daemon_state`: from health context (already injected by context_processor, but also pass explicitly for the status banner logic)
   - `has_image`: bool, whether any captured image exists

2. `GET /image`: Serves the most recently captured image. Implementation:
   - Walk the output directory in REVERSE order (latest year > latest month > latest day > latest file)
   - Skip non-directory entries, the `thumbs/` subdirectory, and non-.jpg files
   - If found, serve via `send_file()` with `Cache-Control: no-store` header and `mimetype="image/jpeg"`
   - If no images exist, return 404

3. `GET /status`: Returns JSON with `{"daemon_state": "running|stopped|error", "last_capture": "ISO timestamp or null", "has_image": true|false}`. Used by JS to update the status banner without a full page reload.

Private helper `_find_latest_image(output_dir: Path) -> Path | None`:
- Iterate year dirs in reverse (sorted, reverse=True)
- For each year, iterate month dirs in reverse
- For each month, iterate day dirs in reverse
- For each day, iterate .jpg files in reverse (skip non-jpg, skip "thumbs" directory)
- Return the first match (newest image) or None

`src/timelapse/web/templates/latest.html` (extends base.html):
- Title block: "Latest Image"
- Content block:
  - Status banner `<div id="status-banner" class="status-banner">`: Hidden by default. Shows when daemon is stopped/error: "Daemon is stopped -- showing last captured image" or "Camera offline -- showing last captured image". Styled with a muted background color to be noticeable but not alarming.
  - Main image area:
    - `<div class="latest-image-container">`
    - `<img id="latest-image" src="{{ url_for('latest.latest_image') }}" alt="Latest capture">` (or a placeholder message if no images exist)
    - Timestamp overlay: `<span id="capture-timestamp" class="image-timestamp">{{ health.last_capture or 'No captures yet' }}</span>` -- small text positioned over the bottom of the image
  - Info bar below the image:
    - "Refreshes every {{ capture_interval }} seconds"
    - Per user decision: display the configured capture interval
  - If no images exist at all: show "No images captured yet. Start the capture daemon to begin."
- Scripts block: include latest.js
- Pass capture_interval to JS via a data attribute: `<div id="latest-config" data-interval="{{ capture_interval }}">`

`src/timelapse/web/static/js/latest.js`:
- Read the capture interval from the data attribute (in seconds), convert to milliseconds
- Set up `setInterval(refreshImage, intervalMs)` to auto-refresh
- `refreshImage()` function:
  - Update `<img>` src to `/latest/image?t=${Date.now()}` (cache-busting)
  - Also fetch `/latest/status` to update the status banner and timestamp
  - On the status response:
    - If daemon_state is "running" and has_image is true: hide the status banner
    - If daemon_state is "stopped": show "Daemon is stopped" banner
    - If daemon_state is "error" or last_capture is stale: show appropriate banner
    - Update the timestamp overlay with last_capture value
- Per user decision: view-only, no "capture now" button
- Per user decision: refreshes at capture interval, not faster
- Handle image load errors gracefully (network issues): keep showing the last successfully loaded image
  </action>
  <verify>
`python -c "
from timelapse.web import create_app
app = create_app()
with app.test_client() as client:
    resp = client.get('/latest/')
    assert resp.status_code == 200
    assert b'latest-image' in resp.data
    assert b'latest.js' in resp.data
    assert b'Refreshes every' in resp.data
    resp2 = client.get('/latest/status')
    assert resp2.status_code == 200
    assert resp2.content_type.startswith('application/json')
    print('Latest Image tab OK')
"`
  </verify>
  <done>Latest Image tab shows the most recent capture, auto-refreshes at the capture interval, displays a status banner when daemon is stopped, and shows the capture timestamp.</done>
</task>

<task type="auto">
  <name>Task 2: Create web server systemd service and update setup script</name>
  <files>systemd/timelapse-web.service, scripts/setup.sh</files>
  <action>
Create `systemd/timelapse-web.service` modeled on the existing `timelapse-capture.service`:

```ini
[Unit]
Description=Timelapse Web UI
After=network.target
# Start after capture daemon so status file exists
After=timelapse-capture.service

[Service]
Type=simple
User=pi
Group=pi
# Use Flask's built-in server -- adequate for single-user local network
# For production at scale, use gunicorn, but Flask's server handles the Pi use case
ExecStart=/home/pi/rpi-timelapse-cam/venv/bin/python -m flask --app timelapse.web run --host 0.0.0.0 --port 8080
# Working directory must contain the src/ package
WorkingDirectory=/home/pi/rpi-timelapse-cam
Restart=on-failure
RestartSec=5
StartLimitBurst=5
StartLimitIntervalSec=300
Environment=PYTHONUNBUFFERED=1
Environment=FLASK_APP=timelapse.web
StandardOutput=journal
StandardError=journal
SyslogIdentifier=timelapse-web
# Less memory than capture daemon -- web serving is lighter
MemoryMax=128M
CPUQuota=25%
```

Key differences from timelapse-capture.service:
- Group is `pi` (not `video` -- web server does not need camera hardware access)
- After=network.target (needs network to serve HTTP, not NTP)
- Uses `flask run` command with host/port flags
- Lower resource limits (web serving is lighter than image capture)
- Sets FLASK_APP environment variable

Update `scripts/setup.sh`:
- Add the timelapse-web.service to the systemd install section (copy to /etc/systemd/system/, daemon-reload)
- Add a sudoers drop-in file creation section: create `/etc/sudoers.d/timelapse-web` with:
  ```
  pi ALL=(root) NOPASSWD: /usr/bin/systemctl start timelapse-capture
  pi ALL=(root) NOPASSWD: /usr/bin/systemctl stop timelapse-capture
  pi ALL=(root) NOPASSWD: /usr/bin/systemctl is-active timelapse-capture
  ```
  Use the full path to systemctl. Validate with `visudo -cf` after writing.
- Add the web dependencies to the pip install command if not already present (flask, pillow, python-pam, flask-httpauth)
- Print instructions for enabling the web service (same pattern as capture service: print but don't auto-enable)
- Add the shadow group membership instruction for PAM auth: `sudo usermod -aG shadow pi`
  </action>
  <verify>
The systemd service file is valid INI format:
`python -c "
import configparser
c = configparser.ConfigParser()
c.read('/Users/jacobroufa/Code/rpi-timelapse-cam/systemd/timelapse-web.service')
assert 'Service' in c.sections()
assert 'ExecStart' in c['Service']
print('Service file valid')
"`

The setup script references both services:
`grep -q 'timelapse-web' /Users/jacobroufa/Code/rpi-timelapse-cam/scripts/setup.sh && echo 'Setup script updated'`
  </verify>
  <done>timelapse-web.service starts Flask on port 8080, restarts on failure, and runs as the pi user. Setup script installs both services, creates sudoers drop-in, and prints enable instructions.</done>
</task>

</tasks>

<verification>
- GET /latest/ renders the Latest Image page with auto-refresh
- GET /latest/image serves the most recent JPEG with Cache-Control: no-store (or 404 if no images)
- GET /latest/status returns JSON with daemon state
- latest.js sets up polling at the configured capture interval
- systemd/timelapse-web.service is valid and references flask run
- scripts/setup.sh installs both systemd services and creates sudoers file
</verification>

<success_criteria>
- Latest Image tab displays the most recently captured image
- Image auto-refreshes at the configured capture interval with cache-busting
- Status banner appears when daemon is stopped or camera is offline
- Timestamp overlay shows when the displayed image was captured
- Capture interval is displayed on the page
- No manual "capture now" button (view-only per user decision)
- Web server systemd service starts Flask on boot
- Sudoers file limits passwordless sudo to exactly three systemctl commands
</success_criteria>

<output>
After completion, create `.planning/phases/02-web-ui-timeline-browser/02-04-SUMMARY.md`
</output>
