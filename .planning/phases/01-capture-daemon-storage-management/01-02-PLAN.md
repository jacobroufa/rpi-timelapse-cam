---
phase: 01-capture-daemon-storage-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/timelapse/camera/__init__.py
  - src/timelapse/camera/base.py
  - src/timelapse/camera/picamera.py
  - src/timelapse/camera/usb.py
  - src/timelapse/camera/detect.py
  - src/timelapse/lock.py
autonomous: true
requirements:
  - CAP-01
  - CAP-02
  - CAP-09
  - CAP-10

must_haves:
  truths:
    - "Auto-detection tries picamera2 first, falls back to OpenCV USB, raises clear error if neither available"
    - "Pi Camera backend captures JPEG with configurable quality via PIL Image.save()"
    - "USB webcam backend captures JPEG with configurable quality via cv2.imwrite IMWRITE_JPEG_QUALITY"
    - "Camera source can be forced to picamera or usb via config, or left as auto"
    - "Capture calls are wrapped with a timeout to prevent hangs (max 30 seconds)"
    - "Camera lock file prevents simultaneous access using fcntl.flock"
  artifacts:
    - path: "src/timelapse/camera/base.py"
      provides: "Abstract CameraBackend interface"
      contains: "class CameraBackend"
    - path: "src/timelapse/camera/picamera.py"
      provides: "Pi Camera backend using picamera2"
      contains: "class PiCameraBackend"
    - path: "src/timelapse/camera/usb.py"
      provides: "USB webcam backend using OpenCV"
      contains: "class USBCameraBackend"
    - path: "src/timelapse/camera/detect.py"
      provides: "Camera auto-detection and factory function"
      contains: "def detect_camera"
    - path: "src/timelapse/lock.py"
      provides: "File-based camera mutex"
      contains: "fcntl.flock"
  key_links:
    - from: "src/timelapse/camera/picamera.py"
      to: "picamera2.Picamera2"
      via: "import and instantiate for Pi Camera capture"
      pattern: "from picamera2 import Picamera2"
    - from: "src/timelapse/camera/usb.py"
      to: "cv2.VideoCapture"
      via: "import and instantiate for USB webcam capture"
      pattern: "cv2.VideoCapture"
    - from: "src/timelapse/camera/detect.py"
      to: "PiCameraBackend, USBCameraBackend"
      via: "tries picamera2 first, falls back to USB"
      pattern: "is_available"
    - from: "src/timelapse/lock.py"
      to: "fcntl.flock"
      via: "exclusive lock context manager"
      pattern: "LOCK_EX"
---

<objective>
Build the camera abstraction layer: abstract backend interface, Pi Camera backend (picamera2), USB webcam backend (OpenCV), auto-detection logic, capture timeout protection, and camera lock file for inter-process safety.

Purpose: The daemon needs a unified camera interface that works with both Pi Camera and USB webcams. This plan creates the two backends, the detection/factory logic, and the lock file -- all independent of the config and storage modules (Plan 01).
Output: Complete camera subsystem ready to be consumed by the daemon loop (Plan 03).
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-capture-daemon-storage-management/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create camera backends with abstract interface, Pi Camera, and USB implementations</name>
  <files>
    src/timelapse/camera/__init__.py
    src/timelapse/camera/base.py
    src/timelapse/camera/picamera.py
    src/timelapse/camera/usb.py
  </files>
  <action>
    Create the camera abstraction layer with two concrete backends.

    **src/timelapse/camera/base.py:**
    - `CameraBackend` abstract base class (ABC) with these abstract methods:
      - `open(self) -> None` -- initialize and start camera pipeline. Keep it open for reuse between captures.
      - `capture(self, output_path: Path, quality: int = 85) -> bool` -- capture single JPEG. Returns True on success. Must create parent directories.
      - `close(self) -> None` -- release camera resources.
      - `is_available(self) -> bool` -- check if this camera type is currently connected/available.
    - Also define a concrete property `name -> str` that subclasses set (for logging).

    **src/timelapse/camera/picamera.py:**
    - `PiCameraBackend(CameraBackend)` class
    - Constructor takes `resolution: tuple[int, int] = (1920, 1080)`
    - `open()`: import picamera2 lazily (at call time, not module level -- so the module is importable on machines without picamera2). Create Picamera2 instance, `create_still_configuration(main={"size": resolution})`, configure, start. Sleep 2 seconds for AE/AWB to settle.
    - `capture()`: call `self._camera.capture_image("main")` to get PIL Image. Create parent dirs with `output_path.parent.mkdir(parents=True, exist_ok=True)`. Save with `img.save(str(output_path), quality=quality)`. Return True. CRITICAL: use `capture_image()` + PIL save, NOT `capture_file()` -- capture_file has no quality parameter (see research: picamera2 JPEG quality trap).
    - `close()`: stop and close camera if initialized. Guard against double-close.
    - `is_available()`: try to import picamera2, instantiate Picamera2(), immediately close(). Return True if no exception. Catch all exceptions and return False.
    - `name` property returns `"picamera"`
    - Logger: `timelapse.camera.picamera`

    **src/timelapse/camera/usb.py:**
    - `USBCameraBackend(CameraBackend)` class
    - Constructor takes `device_index: int = 0, resolution: tuple[int, int] = (1920, 1080)`
    - `open()`: `cv2.VideoCapture(device_index, cv2.CAP_V4L2)`. Check `isOpened()`, raise RuntimeError if not. Set frame width/height. Sleep 0.5s for auto-exposure. Import cv2 lazily.
    - `capture()`: `self._cap.read()` -- if ret is False, return False. Create parent dirs. Use `cv2.imwrite(str(output_path), frame, [int(cv2.IMWRITE_JPEG_QUALITY), quality])`. Return True.
    - `close()`: release capture if initialized. Guard against double-close.
    - `is_available()`: try opening VideoCapture, check isOpened(), release, return result. Catch exceptions return False. Import cv2 lazily.
    - `name` property returns `"usb"`
    - Logger: `timelapse.camera.usb`
    - CRITICAL: OpenCV does NOT work with Pi Camera on Bookworm. This backend is for USB webcams ONLY.

    **src/timelapse/camera/__init__.py:**
    - Import and re-export `CameraBackend` from `.base`
    - Import and re-export `PiCameraBackend` from `.picamera`
    - Import and re-export `USBCameraBackend` from `.usb`
    - Import and re-export `detect_camera` from `.detect` (will exist after Task 2)
    - Use conditional imports with try/except so the package is importable even if picamera2 or cv2 are not installed
  </action>
  <verify>
    `PYTHONPATH=src python -c "from timelapse.camera.base import CameraBackend; print('Base OK')"` succeeds.
    `PYTHONPATH=src python -c "from timelapse.camera.picamera import PiCameraBackend; print('PiCamera import OK')"` succeeds (module importable even without picamera2 hardware).
    `PYTHONPATH=src python -c "from timelapse.camera.usb import USBCameraBackend; print('USB import OK')"` succeeds (module importable even without cv2 installed, though cv2 should be available via system packages).
  </verify>
  <done>
    Abstract CameraBackend defines the interface. PiCameraBackend captures via picamera2 with PIL JPEG quality control. USBCameraBackend captures via OpenCV with IMWRITE_JPEG_QUALITY. Both use lazy imports for hardware libraries. Both keep the camera open between captures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create camera auto-detection, capture timeout wrapper, and lock file</name>
  <files>
    src/timelapse/camera/detect.py
    src/timelapse/lock.py
  </files>
  <action>
    Create the detection/factory function, timeout protection, and camera lock.

    **src/timelapse/camera/detect.py:**
    - `detect_camera(config: dict) -> CameraBackend` factory function
    - Read `config["capture"]["source"]` -- values: `"auto"`, `"picamera"`, `"usb"`
    - Read `config["capture"]["resolution"]` as tuple
    - If source is `"picamera"`: instantiate PiCameraBackend(resolution). If is_available() is False, raise RuntimeError with clear message.
    - If source is `"usb"`: instantiate USBCameraBackend(device_index=config.get("capture", {}).get("device_index", 0), resolution=resolution). If is_available() is False, raise RuntimeError.
    - If source is `"auto"`: try PiCameraBackend first. If is_available(), return it. Otherwise try USBCameraBackend. If is_available(), return it. If neither, raise RuntimeError with message listing both failures.
    - Log which camera was selected at INFO level.
    - Logger: `timelapse.camera.detect`

    - Also in detect.py (or as a wrapper in base.py -- your choice, but keep it close to camera code):
    - `capture_with_timeout(camera: CameraBackend, output_path: Path, quality: int, timeout: int = 30) -> bool` function
    - Runs `camera.capture(output_path, quality)` in a separate thread using `threading.Thread`
    - Joins with `timeout` seconds
    - If the thread is still alive after timeout, log an error and return False
    - If capture completed, return the result
    - This satisfies CAP-09 (capture timeout to prevent hangs)

    **src/timelapse/lock.py:**
    - `camera_lock(lock_path: str = "/tmp/timelapse-camera.lock", blocking: bool = True)` context manager using `@contextmanager`
    - Opens lock file for writing
    - Acquires `fcntl.flock` with `LOCK_EX`. If `blocking=False`, adds `LOCK_NB` flag.
    - Writes PID to lock file via `os.getpid()`
    - On exit: unlocks with `LOCK_UN`, closes file descriptor
    - Non-blocking mode raises `BlockingIOError` if lock is held (web server can catch this in Phase 2)
    - Logger: `timelapse.lock`
  </action>
  <verify>
    `PYTHONPATH=src python -c "from timelapse.camera.detect import detect_camera, capture_with_timeout; print('Detect OK')"` succeeds.
    `PYTHONPATH=src python -c "from timelapse.lock import camera_lock; print('Lock OK')"` succeeds.
    Test the lock: `PYTHONPATH=src python -c "
from timelapse.lock import camera_lock
with camera_lock() as _:
    print('Lock acquired')
print('Lock released')
"` succeeds without errors.
  </verify>
  <done>
    Auto-detection tries picamera2 first, falls back to USB, raises clear error if neither available. Forced source mode validates availability before returning. Capture timeout wrapper prevents hangs using threading with 30-second default. Camera lock file uses fcntl.flock for inter-process mutex.
  </done>
</task>

</tasks>

<verification>
1. All camera modules importable: base, picamera, usb, detect
2. Lock module importable and functional (acquire/release cycle works)
3. detect_camera raises RuntimeError with clear message when no camera available (expected on dev machine)
4. capture_with_timeout returns False after timeout period (testable with a mock)
5. CameraBackend interface defines open, capture, close, is_available
</verification>

<success_criteria>
- Two separate camera backends (picamera2 and OpenCV) behind a unified abstract interface
- Auto-detection tries picamera2 first, falls back to USB, with forced-source option
- Capture calls protected by 30-second timeout via threading
- Camera lock file prevents simultaneous access using fcntl.flock
- All modules importable on machines without camera hardware (lazy imports)
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-daemon-storage-management/01-02-SUMMARY.md`
</output>
