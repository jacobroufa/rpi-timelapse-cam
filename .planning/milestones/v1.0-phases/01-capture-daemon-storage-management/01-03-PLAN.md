---
phase: 01-capture-daemon-storage-management
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/timelapse/daemon.py
  - src/timelapse/__main__.py
  - src/timelapse/status.py
  - systemd/timelapse-capture.service
  - scripts/setup.sh
autonomous: true
requirements:
  - CAP-03
  - CAP-05

must_haves:
  truths:
    - "Daemon captures images at the configured interval with drift-corrected sleep"
    - "Daemon checks disk space before each capture and skips when full"
    - "Daemon runs cleanup after each capture if auto-cleanup is enabled"
    - "Daemon recovers from camera disconnects with exponential backoff"
    - "Daemon reloads config on SIGHUP without restart"
    - "Daemon writes JSON status file after each capture cycle"
    - "systemd service starts on boot, restarts on crash, depends on time-sync.target"
    - "Setup script creates venv, installs dependencies, installs systemd unit"
  artifacts:
    - path: "src/timelapse/daemon.py"
      provides: "Main capture loop with signal handling and backoff"
      contains: "class CaptureDaemon"
    - path: "src/timelapse/__main__.py"
      provides: "CLI entry point: python -m timelapse"
      contains: "def main"
    - path: "src/timelapse/status.py"
      provides: "Atomic JSON status file writer"
      contains: "write_status"
    - path: "systemd/timelapse-capture.service"
      provides: "systemd service unit"
      contains: "Restart=on-failure"
    - path: "scripts/setup.sh"
      provides: "Quick install script"
      contains: "venv"
  key_links:
    - from: "src/timelapse/daemon.py"
      to: "src/timelapse/config.py"
      via: "loads config at start, reloads on SIGHUP"
      pattern: "load_config"
    - from: "src/timelapse/daemon.py"
      to: "src/timelapse/camera/detect.py"
      via: "detect_camera creates backend, capture_with_timeout wraps captures"
      pattern: "detect_camera"
    - from: "src/timelapse/daemon.py"
      to: "src/timelapse/storage/manager.py"
      via: "has_space check before capture, image_path for output"
      pattern: "has_space"
    - from: "src/timelapse/daemon.py"
      to: "src/timelapse/lock.py"
      via: "camera_lock context manager around capture"
      pattern: "camera_lock"
    - from: "systemd/timelapse-capture.service"
      to: "src/timelapse/__main__.py"
      via: "ExecStart runs python -m timelapse"
      pattern: "ExecStart"
---

<objective>
Build the capture daemon loop, CLI entry point, status reporting, systemd service unit, and setup script. This plan wires together the config (Plan 01) and camera (Plan 02) subsystems into a running daemon.

Purpose: This is the integration plan that makes the capture system actually run. Without it, the config and camera modules are just libraries.
Output: A daemon that captures images on an interval, manages storage, recovers from errors, and runs as a systemd service.
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-capture-daemon-storage-management/01-RESEARCH.md
@.planning/phases/01-capture-daemon-storage-management/01-01-SUMMARY.md
@.planning/phases/01-capture-daemon-storage-management/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create capture daemon loop, status reporter, and CLI entry point</name>
  <files>
    src/timelapse/daemon.py
    src/timelapse/__main__.py
    src/timelapse/status.py
  </files>
  <action>
    Build the main daemon that ties config, camera, and storage together.

    **src/timelapse/status.py:**
    - `write_status(status_path: Path, data: dict) -> None` function
    - Atomic write: write to a temp file in the same directory, then `os.rename()` to the target path
    - This prevents the web server (Phase 2) from reading a partially-written file
    - Status data is a dict with keys: `daemon`, `camera`, `last_capture`, `last_capture_success`, `consecutive_failures`, `captures_today`, `disk_usage_percent`, `disk_free_gb`, `uptime_seconds`, `config_loaded`
    - `read_status(status_path: Path) -> dict | None` function for consumers (returns None if file doesn't exist)
    - Logger: `timelapse.status`

    **src/timelapse/daemon.py:**
    - `CaptureDaemon` class with constructor: `__init__(self, config: dict, config_path: Path)`
    - Constructor initializes: camera (via `detect_camera(config)`), storage manager (via `StorageManager`), state tracking (consecutive_failures, captures_today, start_time)
    - `run()` method -- the main loop:
      1. Register signal handlers: SIGTERM and SIGINT for graceful shutdown (`self._running = False`), SIGHUP for config reload
      2. Open camera via `camera.open()`
      3. Log "Camera opened ({camera.name}), starting capture loop"
      4. Enter while loop (`while self._running`):
         a. Record `loop_start = time.monotonic()`
         b. Call `self._capture_once()`
         c. Write status file via `write_status()`
         d. Calculate drift-corrected sleep: `sleep_time = max(0, config["capture"]["interval"] - elapsed)`
         e. Sleep in small increments (0.5s) checking `self._running` to allow quick shutdown
      5. Finally block: close camera, log "Daemon stopped"

    - `_capture_once()` method:
      1. Check `self._storage.has_space()` -- if False, log error "Disk usage exceeds 90% threshold, skipping capture" and return
      2. Generate `output_path = self._storage.image_path(datetime.now())`
      3. Check if file already exists (collision per user decision: skip duplicate)
      4. Acquire camera lock via `camera_lock(blocking=True)`
      5. Call `capture_with_timeout(self._camera, output_path, config["capture"]["jpeg_quality"], timeout=30)`
      6. On success: reset consecutive_failures to 0, increment captures_today
      7. On failure: increment consecutive_failures, attempt recovery with backoff
      8. Run cleanup if `config["storage"]["cleanup_enabled"]` is True: call `cleanup_old_days(output_dir, retention_days)`
      9. Handle exceptions: log at ERROR level, increment consecutive_failures

    - `_handle_reload(signum, frame)` method (SIGHUP handler):
      1. Log "SIGHUP received, reloading configuration"
      2. Try `load_config(self._config_path)`
      3. On success: update `self._config`, log "Configuration reloaded". Update storage manager thresholds.
      4. On failure: log exception, keep current config
      5. What reloads: interval, jpeg_quality, thresholds, cleanup settings, gap_tracking
      6. What does NOT reload (per research): camera source, resolution, output_dir (log a warning if these changed)

    - Camera disconnect recovery (exponential backoff per discretion recommendation):
      1. On capture failure, increment consecutive_failures counter
      2. Backoff delay: `min(5 * 2**consecutive_failures + random.uniform(0, 1), 300)` (5s base, 300s max)
      3. Close camera, sleep for backoff delay, attempt to reopen
      4. Log disconnect at WARNING, reconnection at INFO
      5. On successful capture after reconnect, reset counter to 0

    - Logging setup: Configure `logging.basicConfig()` with format `"%(asctime)s %(levelname)s %(name)s: %(message)s"` to stderr (systemd captures via journal). Level: INFO. Per user decision: log errors + camera connect/disconnect events, NOT every capture. Only log captures if gap_tracking is enabled.

    **src/timelapse/__main__.py:**
    - `main()` function as CLI entry point
    - Parse `--config` argument via `argparse` (default: `/etc/timelapse/timelapse.yml`, fallback chain: `./config/timelapse.yml` if default not found)
    - Load config via `load_config(config_path)`
    - Validate output directory via `StorageManager.ensure_output_dir()`
    - Create and run `CaptureDaemon(config, config_path)`
    - `if __name__ == "__main__": main()` guard
  </action>
  <verify>
    `PYTHONPATH=src python -c "from timelapse.daemon import CaptureDaemon; print('Daemon OK')"` succeeds.
    `PYTHONPATH=src python -c "from timelapse.status import write_status, read_status; print('Status OK')"` succeeds.
    `PYTHONPATH=src python -m timelapse --help` shows usage with --config argument.
    Test status file: `PYTHONPATH=src python -c "
from timelapse.status import write_status, read_status
from pathlib import Path
import tempfile, os
p = Path(tempfile.mktemp(suffix='.json'))
write_status(p, {'daemon': 'running', 'camera': 'test'})
s = read_status(p)
assert s['daemon'] == 'running'
os.unlink(p)
print('Status file OK')
"`
  </verify>
  <done>
    Daemon captures at configured interval with drift correction. Checks disk space before each capture. Runs cleanup when enabled. Recovers from camera disconnects with exponential backoff (5s base, 300s max). Reloads config on SIGHUP. Writes atomic JSON status file for Phase 2 web UI. CLI entry point accepts --config argument.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create systemd service unit and setup script</name>
  <files>
    systemd/timelapse-capture.service
    scripts/setup.sh
  </files>
  <action>
    Create the systemd service unit and the quick-install setup script.

    **systemd/timelapse-capture.service:**
    - `[Unit]` section:
      - `Description=Timelapse Capture Daemon`
      - `After=time-sync.target` -- Pi has no RTC, must wait for NTP sync to get correct timestamps
      - `Wants=time-sync.target`
    - `[Service]` section:
      - `Type=simple`
      - `User=pi` -- non-root, but with video group for camera access
      - `Group=video` -- required for camera hardware access
      - `ExecStart=/home/pi/rpi-timelapse-cam/venv/bin/python -m timelapse --config /home/pi/timelapse-config.yml`
      - `ExecReload=/bin/kill -HUP $MAINPID` -- enables `systemctl reload timelapse-capture`
      - `Restart=on-failure`
      - `RestartSec=5`
      - `StartLimitBurst=5`
      - `StartLimitIntervalSec=300` -- max 5 restarts in 5 minutes
      - `Environment=PYTHONUNBUFFERED=1` -- ensure Python output reaches journal immediately
      - `StandardOutput=journal`
      - `StandardError=journal`
      - `SyslogIdentifier=timelapse-capture`
      - `MemoryMax=256M` -- prevent runaway memory on constrained Pi
      - `CPUQuota=50%` -- leave headroom for OS and other services
    - `[Install]` section:
      - `WantedBy=multi-user.target`
    - Add comments in the file explaining each non-obvious setting, especially `time-sync.target`, `Group=video`, and `PYTHONUNBUFFERED`
    - Note at top: paths assume default Pi user and project location; edit ExecStart and --config paths for your setup

    **scripts/setup.sh:**
    - Bash script with `#!/usr/bin/env bash` and `set -euo pipefail`
    - Print banner with project name and version
    - Check prerequisites: Python 3.11+, `apt` available (Raspberry Pi OS / Debian)
    - Install system packages: `sudo apt install -y python3-picamera2 python3-opencv python3-pip python3-venv`
    - Create venv with `--system-site-packages` (required for picamera2 and cv2 access per PEP 668)
    - Install Python dependencies: `pip install pyyaml` (inside venv)
    - Copy example config to user's home if it doesn't already exist: `cp config/timelapse.yml ~/timelapse-config.yml`
    - Create default output directory: `mkdir -p ~/timelapse-images`
    - Install systemd unit:
      - Copy service file to `/etc/systemd/system/`
      - `sudo systemctl daemon-reload`
      - Print instructions (do NOT auto-enable -- let user decide):
        - "To start the daemon: sudo systemctl start timelapse-capture"
        - "To enable on boot: sudo systemctl enable timelapse-capture"
        - "To view logs: journalctl -u timelapse-capture -f"
        - "To reload config: sudo systemctl reload timelapse-capture"
    - Add comments throughout explaining each step
    - Print summary at end: config location, output directory, next steps
    - Per user decision: mention /var/lib/timelapse as alternative for production installs in the summary output
    - Script should be idempotent (safe to run multiple times)
  </action>
  <verify>
    `bash -n scripts/setup.sh` -- syntax check passes.
    `grep "time-sync.target" systemd/timelapse-capture.service` -- NTP dependency present.
    `grep "Restart=on-failure" systemd/timelapse-capture.service` -- auto-restart configured.
    `grep "PYTHONUNBUFFERED" systemd/timelapse-capture.service` -- unbuffered output set.
    `grep "system-site-packages" scripts/setup.sh` -- venv created with system packages access.
    `grep "ExecReload" systemd/timelapse-capture.service` -- SIGHUP reload support.
  </verify>
  <done>
    systemd service unit starts daemon on boot, restarts on crash (max 5 in 5 min), depends on NTP time-sync, runs as pi:video user, journals stdout/stderr, supports config reload via SIGHUP/systemctl reload. Setup script installs system packages, creates venv with system-site-packages, copies example config, creates output directory, installs systemd unit, and prints clear next-steps instructions.
  </done>
</task>

</tasks>

<verification>
1. `PYTHONPATH=src python -m timelapse --help` shows usage
2. Daemon module imports successfully and CaptureDaemon class exists
3. Status module writes and reads JSON atomically
4. systemd unit has correct dependencies, restart policy, and environment
5. Setup script passes bash syntax check and is idempotent
6. All signal handlers registered: SIGTERM, SIGINT (shutdown), SIGHUP (reload)
</verification>

<success_criteria>
- Daemon captures at configured interval with drift-corrected sleep
- Pre-capture disk check refuses to write at 90% usage
- Cleanup runs after each capture when enabled
- Camera disconnect triggers exponential backoff recovery (5s base, 300s max)
- SIGHUP reloads config without restart (interval, quality, thresholds)
- JSON status file written atomically after each cycle
- systemd service starts on boot, restarts on crash, depends on time-sync.target
- Setup script creates venv with --system-site-packages, installs deps, copies config
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-daemon-storage-management/01-03-SUMMARY.md`
</output>
