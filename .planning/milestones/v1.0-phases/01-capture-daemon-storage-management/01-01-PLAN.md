---
phase: 01-capture-daemon-storage-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/timelapse/__init__.py
  - src/timelapse/config.py
  - src/timelapse/storage/__init__.py
  - src/timelapse/storage/manager.py
  - src/timelapse/storage/cleanup.py
  - config/timelapse.yml
autonomous: true
requirements:
  - CAP-04
  - CAP-06
  - CAP-07
  - CAP-08
  - STR-01
  - STR-02
  - STR-03

must_haves:
  truths:
    - "YAML config file is loaded with defaults applied for all settings (interval, source, quality, resolution, output_dir, thresholds, cleanup, retention)"
    - "Image paths follow YYYY/MM/DD/HHMMSS.jpg structure derived from timestamps"
    - "Disk usage check returns False when usage exceeds 90% threshold"
    - "Warning is logged when disk usage exceeds the warn threshold (default 85%)"
    - "Cleanup deletes oldest full day directories when retention period exceeded"
    - "Cleanup is off by default and must be explicitly enabled"
  artifacts:
    - path: "src/timelapse/config.py"
      provides: "YAML config loading with validation and defaults"
      contains: "safe_load"
    - path: "src/timelapse/storage/manager.py"
      provides: "Disk space checking, image path generation"
      contains: "disk_usage"
    - path: "src/timelapse/storage/cleanup.py"
      provides: "Age-based day directory cleanup"
      contains: "rmtree"
    - path: "config/timelapse.yml"
      provides: "Example/default configuration file"
      contains: "capture:"
    - path: "pyproject.toml"
      provides: "Project metadata and dependencies"
      contains: "pyyaml"
  key_links:
    - from: "src/timelapse/config.py"
      to: "config/timelapse.yml"
      via: "yaml.safe_load reads config file"
      pattern: "safe_load"
    - from: "src/timelapse/storage/manager.py"
      to: "shutil.disk_usage"
      via: "pre-capture disk check"
      pattern: "disk_usage"
    - from: "src/timelapse/storage/cleanup.py"
      to: "date directory structure"
      via: "walks YYYY/MM/DD dirs and removes oldest full days"
      pattern: "rmtree"
---

<objective>
Create the project foundation: Python package scaffolding, YAML configuration module with validation and defaults, storage manager with disk space checking and image path generation, and age-based cleanup of day directories.

Purpose: Everything else in Phase 1 depends on config loading and storage management. This plan establishes the project structure and the two modules that every other component imports.
Output: Working config loader, storage manager, cleanup module, example config file, and pyproject.toml.
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-capture-daemon-storage-management/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffolding and YAML configuration module</name>
  <files>
    pyproject.toml
    src/timelapse/__init__.py
    src/timelapse/config.py
    config/timelapse.yml
  </files>
  <action>
    Create the project package structure and configuration system.

    **pyproject.toml:**
    - Project name: `rpi-timelapse-cam`
    - Python requires: `>=3.11`
    - Dependencies: `pyyaml>=6.0`
    - Optional dependencies group `camera`: `picamera2>=0.3.33`, `opencv-python-headless>=4.9`
    - Console script entry point: `timelapse = timelapse.__main__:main`
    - Include `src` layout (packages under `src/`)

    **src/timelapse/__init__.py:**
    - Package version string `__version__ = "0.1.0"`
    - Empty otherwise

    **src/timelapse/config.py:**
    - `load_config(config_path: Path) -> dict` function
    - Uses `yaml.safe_load()` (NEVER `yaml.load()`)
    - Deep-merges user config over these defaults:
      ```
      capture:
        interval: 60          # 1 minute per user decision (NOT 30s from requirements -- user overrode)
        source: "auto"         # auto | picamera | usb
        jpeg_quality: 85       # per user decision
        resolution: [1920, 1080]  # up to 1080p, downscale if higher
      storage:
        output_dir: "~/timelapse-images"  # expand ~ at load time via Path.expanduser()
        stop_threshold: 90     # refuse to write above 90% usage per user decision
        warn_threshold: 85     # log warning above 85%
        cleanup_enabled: false # off by default per user decision
        retention_days: 30     # per user decision
      logging:
        gap_tracking: false    # opt-in per user decision -- silent on missed captures by default
      ```
    - Validate at load time: interval > 0, quality 1-100, thresholds 0-100, retention_days > 0
    - Raise `SystemExit` with clear message on invalid config or missing file
    - Expand `~` in `output_dir` using `Path.expanduser()`
    - Return a dict (not a dataclass -- keep it simple for SIGHUP reload)

    **config/timelapse.yml:**
    - Example config with ALL settings commented out (so defaults apply)
    - Each setting has a comment explaining what it does, its default, and valid values
    - Include a comment block at top explaining: "Uncomment and modify settings below. Defaults are shown."
    - Include a comment about /var/lib/timelapse as alternative for production installs per user decision
  </action>
  <verify>
    `python -c "from timelapse.config import load_config; from pathlib import Path; c = load_config(Path('config/timelapse.yml')); assert c['capture']['interval'] == 60; assert c['storage']['cleanup_enabled'] == False; assert c['capture']['jpeg_quality'] == 85; print('Config OK')"` succeeds from project root with PYTHONPATH=src
  </verify>
  <done>
    Config module loads YAML, applies defaults, validates values, expands paths. Example config file documents all settings. pyproject.toml defines project metadata and dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create storage manager with disk checking and day-based cleanup</name>
  <files>
    src/timelapse/storage/__init__.py
    src/timelapse/storage/manager.py
    src/timelapse/storage/cleanup.py
  </files>
  <action>
    Create the storage management subsystem.

    **src/timelapse/storage/__init__.py:**
    - Import and re-export `StorageManager` from `.manager` and `cleanup_old_days` from `.cleanup`

    **src/timelapse/storage/manager.py:**
    - `StorageManager` class with constructor: `__init__(self, output_dir: Path, stop_threshold: float = 90.0, warn_threshold: float = 85.0)`
    - `disk_usage_percent() -> float`: uses `shutil.disk_usage(self._output_dir)` to return `(used/total) * 100`
    - `has_space() -> bool`: returns False if usage >= stop_threshold. Logs warning (via `logging.getLogger(__name__)`) if usage >= warn_threshold but below stop. Returns True otherwise.
    - `image_path(timestamp: datetime) -> Path`: generates `output_dir/YYYY/MM/DD/HHMMSS.jpg` using `strftime`. Creates parent directories with `mkdir(parents=True, exist_ok=True)`.
    - `ensure_output_dir()`: validates output_dir exists and is writable. Creates it if it doesn't exist. Raises `SystemExit` if it cannot be created or is not writable.
    - Use `logging` module throughout. Logger name: `timelapse.storage.manager`.

    **src/timelapse/storage/cleanup.py:**
    - `cleanup_old_days(output_dir: Path, retention_days: int) -> int` function
    - Walks the YYYY/MM/DD directory structure under output_dir
    - For each day directory, parses the date from the path (year_dir.name/month_dir.name/day_dir.name)
    - If the date is older than `datetime.now() - timedelta(days=retention_days)`, remove the ENTIRE day directory with `shutil.rmtree()`
    - Per user decision: removes oldest full days first to keep complete days intact
    - Skip non-date directories silently (catches ValueError from strptime)
    - After removing day directories, clean up empty month and year directories
    - Returns count of day directories deleted
    - Logs each deletion at INFO level. Logger name: `timelapse.storage.cleanup`.
  </action>
  <verify>
    Write a quick test inline: create temp directories mimicking YYYY/MM/DD structure with files older than 1 day and today. Run cleanup with retention_days=0. Verify old directories deleted, today's preserved. Also verify `StorageManager.image_path()` produces correct format and `has_space()` returns True on a non-full disk. Run with `python -c "..."` from project root with PYTHONPATH=src.
  </verify>
  <done>
    StorageManager checks disk space before capture, generates date-organized image paths, and validates the output directory. Cleanup function removes oldest full day directories past retention threshold. Empty parent directories cleaned up after deletion.
  </done>
</task>

</tasks>

<verification>
1. `PYTHONPATH=src python -c "from timelapse.config import load_config"` -- config module importable
2. `PYTHONPATH=src python -c "from timelapse.storage import StorageManager, cleanup_old_days"` -- storage module importable
3. Config loads with correct defaults when given the example YAML
4. StorageManager.image_path produces paths like `output_dir/2026/02/16/143000.jpg`
5. StorageManager.has_space returns True on a non-full filesystem
6. Cleanup deletes old day directories and preserves recent ones
</verification>

<success_criteria>
- Config module loads YAML with safe_load, applies all defaults per user decisions, validates values
- Storage manager checks disk usage against 90% hard stop and 85% warning thresholds
- Image paths follow YYYY/MM/DD/HHMMSS.jpg structure
- Cleanup removes oldest full days when retention is exceeded, off by default
- All files exist and are importable as Python modules
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-daemon-storage-management/01-01-SUMMARY.md`
</output>
