---
phase: 02-web-ui-timeline-browser
plan: 05
type: execute
wave: 2
depends_on: [02-02]
files_modified:
  - src/timelapse/web/auth.py
  - src/timelapse/web/blueprints/control.py
  - src/timelapse/web/templates/control.html
  - src/timelapse/web/static/js/control.js
autonomous: true
requirements: [WEB-08]

must_haves:
  truths:
    - "Control tab requires PAM authentication before any content is visible"
    - "Authenticated user sees Start and Stop buttons for the capture daemon"
    - "Stop button shows a confirmation prompt before stopping the daemon"
    - "Start button does not require confirmation"
    - "Inline status text updates in place: Starting..., Running, Stopped"
    - "Control tab displays comprehensive system health: full disk info, uptime, daemon state, config summary"
  artifacts:
    - path: "src/timelapse/web/auth.py"
      provides: "PAM authentication wrapper for Flask-HTTPAuth"
      exports: ["auth"]
      contains: "pam"
    - path: "src/timelapse/web/blueprints/control.py"
      provides: "Control tab routes with PAM-protected daemon management"
      exports: ["control_bp"]
      contains: "login_required"
    - path: "src/timelapse/web/templates/control.html"
      provides: "Control panel with start/stop buttons and system health dashboard"
      contains: "start-btn"
    - path: "src/timelapse/web/static/js/control.js"
      provides: "Start/stop button handlers, confirmation dialog, status polling"
      contains: "confirm"
  key_links:
    - from: "src/timelapse/web/auth.py"
      to: "python-pam"
      via: "pam.pam().authenticate() for credential verification"
      pattern: "authenticate"
    - from: "src/timelapse/web/blueprints/control.py"
      to: "src/timelapse/web/auth.py"
      via: "@auth.login_required decorator on all control routes"
      pattern: "login_required"
    - from: "src/timelapse/web/blueprints/control.py"
      to: "subprocess"
      via: "sudo systemctl start/stop/is-active timelapse-capture"
      pattern: "systemctl"
    - from: "src/timelapse/web/static/js/control.js"
      to: "src/timelapse/web/blueprints/control.py"
      via: "POST /control/start and /control/stop endpoints"
      pattern: "control/(start|stop)"
---

<objective>
Build the Control tab with PAM authentication, daemon start/stop controls, and comprehensive system health dashboard. The Control tab requires Linux system credentials (via HTTP Basic Auth against PAM) before showing any content. Once authenticated, users can manage the capture daemon and view detailed system health information.

Purpose: The Control tab provides daemon management and serves as the full system dashboard. PAM authentication prevents unauthorized users on the local network from stopping the capture daemon. Per user decision, this tab has dedicated Start and Stop buttons (not a toggle), with a confirmation prompt on Stop.

Output: PAM-authenticated Control tab with daemon start/stop, status polling, and full system health display.
</objective>

<execution_context>
@/Users/jacobroufa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacobroufa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-web-ui-timeline-browser/02-RESEARCH.md
@.planning/phases/02-web-ui-timeline-browser/02-02-SUMMARY.md
@src/timelapse/web/__init__.py
@src/timelapse/web/health.py
@src/timelapse/web/blueprints/control.py
@src/timelapse/web/templates/base.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PAM auth module and control blueprint with systemctl integration</name>
  <files>src/timelapse/web/auth.py, src/timelapse/web/blueprints/control.py</files>
  <action>
Create `src/timelapse/web/auth.py`:
- Import `pam` (from python-pam) and `HTTPBasicAuth` from flask_httpauth
- Create a module-level `auth = HTTPBasicAuth()` instance
- Register a `@auth.verify_password` callback:
  - Takes username and password
  - Returns None if either is empty
  - Creates a `pam.pam()` instance and calls `p.authenticate(username, password)`
  - Returns the username on success, None on failure
  - Log authentication failures at WARNING level (but not the password)
- This module is imported by the control blueprint and the auth instance is used as a decorator

Replace the stub control blueprint with the full implementation in `src/timelapse/web/blueprints/control.py`:

Import the auth instance: `from timelapse.web.auth import auth`

Routes (ALL decorated with `@auth.login_required`):

1. `GET /` (control.index): Renders control.html. Passes:
   - `service_status`: result of `_get_service_status()` (active/inactive/failed/unknown)
   - `system_info`: result of `get_full_system_info()` from health module
   - `health_summary`: from context processor (already available)
   - `config_summary`: relevant config values for display (interval, quality, source, output_dir, thresholds, cleanup settings)
   - `user`: `auth.current_user()` for display

2. `POST /start`: Starts the capture service. Calls `subprocess.run(["sudo", "systemctl", "start", "timelapse-capture"], capture_output=True, text=True, timeout=10)`. Returns JSON: `{"success": true/false, "status": "active/inactive/...", "message": "Service started" or error text}`.

3. `POST /stop`: Stops the capture service. Same pattern as start but with "stop". Returns JSON with success, status, message.

4. `GET /status`: Returns JSON with current service status and health data. Used by JS for polling: `{"service_status": "active/inactive/failed", "health": {...full health summary...}, "system_info": {...}}`.

Private helper functions:
- `_get_service_status() -> str`: Runs `sudo systemctl is-active timelapse-capture`, returns stdout.strip() (active, inactive, failed, etc.). Returns "unknown" on error or timeout.
- `_start_service() -> tuple[bool, str]`: Runs sudo systemctl start, returns (success_bool, message).
- `_stop_service() -> tuple[bool, str]`: Runs sudo systemctl stop, returns (success_bool, message).

All subprocess calls use `timeout=10` and `capture_output=True, text=True`. Wrap in try/except for subprocess.TimeoutExpired and other errors.

Important: Use the full path `/usr/bin/systemctl` in subprocess calls to match the sudoers file exactly. The service name is `timelapse-capture` (the capture daemon, not the web server).
  </action>
  <verify>
`python -c "
from timelapse.web.auth import auth
from timelapse.web.blueprints.control import control_bp
print('Auth module and control blueprint import OK')
"`

`python -c "
from timelapse.web import create_app
app = create_app()
with app.test_client() as client:
    # Control tab should require auth (401 without credentials)
    resp = client.get('/control/')
    assert resp.status_code == 401
    print('Control tab requires authentication: OK')
"`
  </verify>
  <done>PAM auth module verifies Linux credentials via python-pam. Control blueprint requires auth on all routes. Start/stop endpoints call systemctl via sudo. Status endpoint returns service state and health data.</done>
</task>

<task type="auto">
  <name>Task 2: Create control template and interactive JavaScript</name>
  <files>src/timelapse/web/templates/control.html, src/timelapse/web/static/js/control.js</files>
  <action>
Create `src/timelapse/web/templates/control.html` (extends base.html):

Title block: "Control"

Content block structure:

1. **Welcome/auth header**: "Logged in as {{ user }}" with a small note about the session

2. **Daemon Control section** (`<section class="daemon-control">`):
   - Heading: "Capture Daemon"
   - Status display: `<span id="service-status" class="service-status {{ service_status }}">{{ service_status | capitalize }}</span>` -- styled with color based on state (green for active, red for inactive, orange for failed)
   - Two buttons in a row:
     - `<button id="start-btn" class="start-btn" {% if service_status == 'active' %}disabled{% endif %}>Start</button>` -- primary/green style
     - `<button id="stop-btn" class="stop-btn" {% if service_status != 'active' %}disabled{% endif %}>Stop</button>` -- secondary/red style
   - Per user decision: Start is safe (no confirmation), Stop shows confirmation prompt
   - Inline status message area: `<span id="action-message"></span>` for "Starting...", "Stopped", etc.

3. **System Health section** (`<section class="system-health">`):
   - This is the comprehensive health dashboard per user decision (Control tab = full dashboard)
   - Grid layout with cards/sections:

   **Disk Storage card:**
   - Total / Used / Free in GB
   - Usage percentage with a visual bar
   - Warning state highlighted if above threshold

   **Capture Stats card:**
   - Daemon state
   - Last capture time
   - Captures today count
   - Consecutive failures (if > 0, highlight)
   - Camera type

   **System Info card:**
   - System uptime
   - Daemon uptime (from status file)
   - Config file path

   **Configuration Summary card:**
   - Capture interval
   - JPEG quality
   - Camera source
   - Output directory
   - Disk thresholds (warn / stop)
   - Cleanup enabled (and retention days if enabled)

4. Scripts block: include control.js

Create `src/timelapse/web/static/js/control.js`:

Start button click handler:
- Set action message to "Starting..."
- Disable both buttons during the request
- POST to `/control/start` with appropriate headers (include credentials for Basic Auth: `credentials: "same-origin"`)
- On success: update status display to "Active", enable Stop button, disable Start button, set message to "Service started"
- On failure: re-enable buttons, show error message

Stop button click handler:
- Per user decision: show `confirm("Stop the capture daemon? This will interrupt image capture.")` first
- If user cancels, do nothing
- If confirmed: set action message to "Stopping..."
- Disable both buttons during the request
- POST to `/control/stop` with credentials
- On success: update status display to "Inactive", enable Start button, disable Stop button, set message to "Service stopped"
- On failure: re-enable buttons, show error message

Status polling:
- Set up `setInterval(pollStatus, 5000)` (poll every 5 seconds while on the Control tab)
- `pollStatus()` fetches `GET /control/status` with credentials
- Updates: service status text and color, health values, system info values
- Updates button enabled/disabled state based on current service status

All fetch calls must include `credentials: "same-origin"` so the browser sends the cached Basic Auth credentials.

Add styles to app.css for the control tab (or use Pico's built-in card/section styling):
- `.service-status.active`: green text
- `.service-status.inactive`: muted/red text
- `.service-status.failed`: orange text
- `.start-btn`: green tinted
- `.stop-btn`: red tinted
- `.system-health` grid: 2 columns on desktop, 1 on mobile
- Health cards: subtle border, padding, consistent spacing
  </action>
  <verify>
`python -c "
from timelapse.web import create_app
app = create_app()
with app.test_client() as client:
    # Should get 401 without auth
    resp = client.get('/control/')
    assert resp.status_code == 401
    print('Control tab auth gate: OK')
"`

Verify the JS and CSS files exist:
`ls -la /Users/jacobroufa/Code/rpi-timelapse-cam/src/timelapse/web/static/js/control.js`
  </verify>
  <done>Control tab shows daemon start/stop buttons with confirmation on stop, inline status updates, and comprehensive system health dashboard. Status polls every 5 seconds. All actions require PAM authentication via HTTP Basic Auth.</done>
</task>

</tasks>

<verification>
- GET /control/ without credentials returns 401
- GET /control/ with valid credentials returns 200 with start/stop buttons and health dashboard
- POST /control/start returns JSON with success status
- POST /control/stop returns JSON with success status
- GET /control/status returns JSON with service state and health data
- control.js handles confirmation on stop, disables buttons during requests, polls status
- System health dashboard shows disk info, capture stats, system info, and config summary
</verification>

<success_criteria>
- PAM authentication blocks unauthenticated access to the Control tab
- Browser prompts for Linux username/password on first visit
- Start button starts the capture daemon (no confirmation needed)
- Stop button shows confirmation dialog before stopping
- Inline status text updates: "Starting...", "Running", "Stopped"
- Full system health dashboard displays on the Control tab
- Status polls every 5 seconds to keep data fresh
- Button states update based on current daemon status
</success_criteria>

<output>
After completion, create `.planning/phases/02-web-ui-timeline-browser/02-05-SUMMARY.md`
</output>
